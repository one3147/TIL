권한
 - 파일/디렉토리를 사용할 수 있는지 정하는 개념

 - 허가권과 소유권으로 구분
    > 허가권 + 소유권 = 권한

허가권
 - ls -l 명령을 입력했을 때 출력되는 정보 중 개체 형식을 나타내는 첫 글자 뒤에 오는 9개의 글자가 허가권

 - 8가지 문자로 권한을 표현 : r, w, x, -, s, S, t, T
	r, w, x, -  : 일반 권한 표현 문자
	s, S, t, T  : 특수 권한 표현 문자

 - r : 읽기, w : 쓰기, x : 실행/접근, - : 권한 없음
	r : 파일 - 파일 내용 읽기		; cat, head, tail, more, less, vi로 열었을 때 등
	    디렉토리 - 디렉토리 내부 목록 확인	; ls, GUI 환경에서 폴더 들어갔을 때 등

	w : 파일 - 파일 내용 수정		; 문서 편집 후 저장, > 기호를 이용하여 덮어쓰기/내용추가 등
	    디렉토리 - 디렉토리 내부 목록 수정	; 디렉토리 내부 하위 파일/디렉토리의 생성/삭제 등

	x : 파일 - 실행			; 파일에 x가 없으면 일반 문서 파일
					  파일에 x가 있으면 실행 파일(ex. 명령어 등)
	    디렉토리 - 접근		; 디렉토리에 x가 없으면 디렉토리 자체 및 내부의 항목들을
					  절대로 사용할 수 없다(접근이 불가능하기 때문에)

 - 9자리의 권한 문자를 3개씩 끊어서 Owner, Group, Other 영역으로 구분
    > 각 영역에는 r, w, x가 순서대로 들어가고, 특정 권한이 없으면 r, w, x 대신에 -이 들어간다

	Owner	: 소유자(파일/디렉토리를 소유 중인 사용자)를 위한 권한
	Group	: 그룹 사용자(파일/디렉토리를 소유 중인 그룹에 소속된 사용자)를 위한 권한
	Other	: 그 외 사용자(Owner, Group 둘 다 해당되지 않는 사용자)를 위한 권한

	  * 3개의 영역 중 어느 영역의 권한을 적용 받는지에 대한 내용은 소유권에서 결정

	   ex>
		  Owner   |   Group   |   Other
		r   w   x   r   -   x   r   -   x

 - 권한 표현 방법
  1. 문자를 이용한 방법  : r, w, x, - 문자를 차례대로 읽어주는 방법

  2. 숫자를 이용한 방법  : 문자를 바탕으로 숫자 값을 계산
    * 계산 방법
	1) 영역 분리
	2) r = 4, w = 2, x = 1, - = 0 을 각 영역의 문자에 대입 -> 영역별로 합 계산
	3) 각 영역에서 구한 합에 Owner는 100, Group은 10, Other는 1을 곱셈 연산 -> 전체 합 계산


	   ex>
	    1. rwxr-xr-x    > 755

		  Owner   |   Group   |   Other
		r   w   x | r   -   x | r   -   x
		4   2   1 | 4   0   1 | 4   0   1
		    7     |     5     |     5
		  x100    |    x10    |    x1
		   700    +     50    +     5


	    2. rw-r--r--    > 644

		  Owner   |   Group   |   Other
		r   w   - | r   -   - | r   -   -
		4   2   0 | 4   0   0 | 4   0   0
		    6     |     4     |     4
		  x100    |    x10    |    x1
		   600    +     40    +     4


	    3. 375    > -wxrwxr-x

		  Owner   |   Group   |   Other
		    3     |     7     |     5
		0 + 2 + 1 | 4 + 2 + 1 | 4 + 0 + 1
		-   w   x   r   w   x   r   -   x

 - 허가권 변경
	chmod [옵션] 권한값 대상 [대상] ... [대상]

    * 권한 값을 숫자/문자로 입력
	숫자로 입력하면 numeric method	; 변경할 권한 전체를 숫자로 입력
	문자로 입력하면 symbolic method	; 영역 문자에 필요한 권한을 +, - 기호로 더하거나 빼준다
	 > symbolic method에서 사용하는 영역 문자
	    u : owner
	    g : group
	    o : other

소유권
 - 파일/디렉토리를 어느 사용자와 그룹이 소유하고 있는지 나타내는 권한
    > ls -l 명령으로 출력되는 정보 중 링크 개수 뒤에 나오는 사용자명과 그룹명이 소유권

 - 소유권은 두 개의 영역으로 구분
    > 앞에 나오는 정보가 계정명(or UID)  ; 파일/디렉토리를 소유하고 있는 사용자를 표시
      뒤에 나오는 정보가 그룹명(or GID)  ; 파일/디렉토리를 소유하고 있는 그룹을 표시

 - 소유권 변경
	chown [옵션] 권한값 대상 [대상] ... [대상]

    * 권한값 작성 방식( : 기호 대신에 . 기호 사용 가능)
	UID	 > 소유권의 UID 영역 변경
	UID:GID  > 소유권의 UID, GID 영역 변경
	UID:	 > 소유권의 UID, GID를 특정 사용자의 UID, GID로 변경
	:GID	 > 소유권의 GID 영역 변경

허가권과 소유권이 적용되는 방식(중요!!!)
 1. 작업 주체와 작업 대상의 UID, GID 확인
	작업 주체 : 작업을 수행하는(= 명령을 입력하는) 사용자
		   >> 사용자 정보 중 UID, GID(/etc/passwd 파일, id 명령어)

	작업 대상 : 작업(= 명령)의 대상이 되는 파일/디렉토리
		   >> 소유권 UID, GID(ls 명령어 -l 옵션이나 -n 옵션)

 2. 작업 주체와 작업 대상의 UID, GID 비교
   1) UID 비교
	작업 주체와 작업 대상의 UID가 일치하면 허가권의 owner 영역 권한만 적용
	UID가 일치하지 않으면 GID를 비교

   2) GID 비교
	작업 주체와 작업 대상의 GID가 일치하면 허가권의 group 영역 권한만 적용
	GID도 일치하지 않으면 허가권의 other 영역 권한만 적용

특수 권한
 - 특이한 동작을 하는 권한

 - setUID, setGID, sticky bit 3가지의 특수 권한이 있다

	4777	r w s r w x r w x	: setUID
	2777	r w x r w s r w x	: setGID
	1777	r w x r w x r w t	: sticky bit

    * x 위치의 문자가 s/t로 변환(x가 있는 상태였다면 소문자 s/t, 없는 상태였다면 대문자 S/T)
	ex>
	    r w s r - x r - x	: 4755
	    r w S r - x r - x	: 4655

sticky bit
 - 디렉토리에 설정하는 특수 권한

 - 디렉토리 내부에 파일/디렉토리 생성은 권한만 있으면 누구나 가능하지만
   파일/디렉토리 삭제는 대상의 소유자(소유권의 UID)와 관리자만 가능

setUID
 - 실행 파일에 설정하는 특수 권한

 - 파일이 동작하는 동안 owner의 권한을 사용할 수 있도록 해주는 특수 권한
    > 동작하는 동안 owner가 된다라고 생각해도 큰 차이 X

umask
 - 생성하는 파일/디렉토리의 허가권을 제어하는 값
    > 사용자 계정마다 부여되어 있는 값

  * 소유권의 경우 생성 작업을 수행하는(= 명령을 입력한) 사용자의 UID, GID를
    생성되는 파일/디렉토리가 그대로 사용

 - 파일/디렉토리의 최대 기본 값에서 생성 작업을 수행한(= 명령을 입력한) 사용자의
   umask 값을 뺀 나머지가 생성되는 파일/디렉토리의 허가권 값으로 지정
   (파일의 최대 기본 값 : 666, 디렉토리의 최대 기본 값 : 777)

 - 숫자로만 보고 계산을 하면 절대로 안됨
   (파일의 기본 권한에는 x가 없기 때문에 x 자리는 계산을 하지 않는다)

    ex>
	umask 값이 003인 사용자가 파일/디렉토리를 생성하면

	   dir.	   : 774
		r w x r w x r w x
	     -  - - - - - - - w x
		r w x r w x r - -

	   file	   : 664
		r w - r w - r w -
	     -  - - - - - - - w x
		r w - r w - r - -

 - 명령어 형식
	umask	  : umask 확인
	umask 값	  : umask 변경

프로그램 설치 과정
	소스 파일 다운로드 -> compile -> 설정 및 파일 배치 -> 프로그램 실행	: tar + 압축
	패키지 파일 갖고있는 상태 -> 명령어를 이용한 설치 -> 프로그램 실행		: rpm
	(Internet 연결) 명령어를 이용한 설치 -> 프로그램 실행			: yum

압축
 - 파일의 용량을 줄이기 위해 사용

 - 원본 파일 자체가 압축 된다(복사본 생성 후 압축하는 작업 X)

 - 여러 파일을 동시에 압축하면 각각의 파일이 개별 압축

 - 디렉토리 압축 X

 - 명령어

	압축 형식		압축		압축 해제

	.zip		zip		unzip

	.gz		gzip		gunzip (gzip -d)

	.bz2		bzip2		bunzip2 (bzip2 -d)

tar
 - 여러 파일을 묶어서 하나의 파일로 저장
    > 생성되는 결과물도 하나의 파일이기 때문에 압축 가능

 - 파일을 담을 공간을 만들고 거기에 파일을 담아주는 개념
    > tar 파일의 용량이 내부에 저장된 파일들 전체의 합보다 클 수 있다

 - 형식
	tar 파일 생성	 : tar cvf 생성이름.tar 대상 [대상] ... [대상]

	tar 파일 내부 확인	 : tar tvf 파일명

	tar 파일 해체	 : tar xvf 파일명

    * 생성 시 .tar 확장자를 직접 붙여야 한다

rpm
 - redhat package manager; 패키지를 이용한 프로그램/서비스 관리
    * 패키지 : 프로그램을 나눠놓은 조각

 - Linux는 kernel부터 시작하여 모든 구성이 패키지로 이루어져 있고
   패키지는 다른 패키지와 의존 관계에 놓여 있는 경우가 많다
    > 패키지 설치/삭제 과정에서 의존성 관련 오류가 굉장히 많이 나온다

 - rpm은 redhat에서 처음 만들어서 도입했고, redhat 기반의 모든 Linux 에서는 rpm 명령어 사용
    > debian 기반의 Linux에서는 rpm이 아닌 dpkg 명령어 사용

 - 형식
	설치	: rpm -ivh 패키지명-버전.아키텍처.rpm

	확인	: rpm -qa | grep 패키지명

	삭제	: rpm -e 패키지명[-버전.아키텍처]

    * grep : 특정 내용이 들어간 line만 출력

 - 패키지 이름 구조

	vim-filesystem-7.4.629-7.el7.x86_64
	<------------>|<----------->|<---->
	    패키지명	    버전	     아키텍처

  1. 패키지명
	패키지명은 한 단어로 구성되어 있거나 - 기호를 이용하여 여러 단어의 조합으로 구성되어 있다
	(이때 숫자만 단독으로 나오는 경우가 없기 때문에 버전과 구별이 가능)

	한 단어이면 해당 패키지로 설치되는 프로그램 or 서비스 이름을 나타낸다

	여러 단어이면 첫 단어가 설치되는 프로그램 or 서비스 이름이고
	뒤에 이어지는 단어들이 세부 역할을 의미한다

  2. 버전
	버전은 여러가지 세부 버전으로 구성

	7	: major
	4	: minor
	629	: patch
	7	: release
	el7	: OS

	el7	: CentOS 7.X
	el7_9	: CentOS 7.9
	centos	: CentOS all version
	생략	: all OS


  3. 아키텍처
	CPU의 bit와 관련된 내용

	32bit CPU : i386, i586, i686
	64bit CPU : x86_64

	  * 아키텍처에 noarch가 들어가면 32bit와 64bit 혼용 가능한 패키지를 의미

 - 의존성 오류
  1. 확인 방법
	A is needed by B	: B에게 A가 필요하다

    1) 설치할 때
	B를 설치하기 위해서 A가 먼저 설치되어야 한다

    2) 삭제할 때
	B에게 A가 필요하기 때문에 A를 지울 수 없다

  2. 해결 방법
    1) 의존성 오류 메세지를 읽고 해당 내용 해결
	> 설치할 때는 A를 먼저 설치
	  삭제할 때는 B를 지워도 된다면 B를 먼저 삭제

    2) 의존성 오류를 무시하는 보조 옵션 --nodeps 사용
	> 설치할 때는 A 패키지가 없는 경우
	  삭제할 때는 B 패키지가 삭제하면 안되는 중요 패키지인 경우
	  --nodeps 보조옵션을 사용하여 의존성 오류를 무시

  3. 의존성 오류 메세지에 패키지명이 아닌 다른 내용이 출력되는 경우
    1) 파일의 절대경로
	패키지에 해당 파일이 포함되어 있는 경우(일반적으로 삭제할 때 출력)
	파일명을 해당 패키지 이름 처럼 읽으면 된다

    2) lib~~~.so.숫자(~~~)
	~~~ 부분이 패키지를 의미(설치/삭제 전부 출력)
	해당 의존성 오류를 검색하여 패키지명 확인

    3) pkgconfig(~~~)
	~~~ 부분이 패키지를 의미(일반적으로 설치할 때 출력)
	해당 의존성 오류를 검색하여 패키지명 확인

 - rpm 패키지 파일을 구하는 방법
  1. 설치 CD에 있는 rpm 파일을 사용

  2. 인터넷에서 필요한 rpm 파일을 다운로드 받아 사용

 - rpm 작업 시 주의 사항
  1. 의존성 오류는 가급적 무시 X
      > 프로그램이나 서비스가 정상 동작을 못할 수 있다
	(심한경우 운영체제에 문제가 생길 수 있다)

  2. 설치/삭제 작업은 눈에 보이는 순서대로 진행(누락 방지용)
     단, main 패키지가 있는 경우에는 main 패키지를 최우선으로 설치/삭제

  3. 동일 종류의 패키지는 가급적이면 버전 정보를 일치
      > 의존성 오류에 출력되는 내용
	  패키지명 = 버전 : 해당 버전의 패키지
	  패키지명 > 버전 : 해당 버전보다 높은 버전의 패키지

  4. 패키지 설치 시 * 기호를 이용하여 모든 패키지를 한번에 설치 X
      > 의존성 오류 발생 시 패키지 의존 관계 확인이 힘들다

yum
 - Internet을 이용한 자동 패키지 관리

 - 반드시 Internet이 연결되어 있어야 사용 가능

 - 패키지 파일 다운로드를 포함한 설치가 가능
    + 설치/삭제 시 의존성 오류를 알아서 처리

 - 형식
	yum [옵션] { install | update | remove } 패키지명

		install	: 설치
		update	: 업데이트
		remove	: 삭제

    * 옵션
	-y	: y/N 물어볼 때 자동으로 y 선택
